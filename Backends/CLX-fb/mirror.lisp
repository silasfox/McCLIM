(in-package #:clim-clx-fb)

(defclass clx-fb-mirror (image-mirror-mixin clx-mirror)
  ((clx-image :initform nil :accessor mirror-clx-image)
   (gcontext  :initform nil :accessor mirror-gcontext)))

(defmethod mcclim-render::%create-mirror-image :after ((mirror clx-fb-mirror) w h)
  (setf (mcclim-render:image-dirty-region mirror) +nowhere+)
  (let* ((data (clime:pattern-array (image-mirror-image mirror)))
         (w (array-dimension data 1))
         (h (array-dimension data 0)))
    (setf (mirror-clx-image mirror)
          (xlib:create-image :bits-per-pixel 32 :data data :depth 24
                             :width w :height h :format :z-pixmap))))

(defun image-mirror-put (mirror image dirty-region)
  (let ((clx-image (mirror-clx-image mirror))
        (gcontext (mirror-gcontext mirror))
        (window (window mirror))
        (window-region (bounding-rectangle image)))
    (flet ((put-it (region)
             (with-bounding-rectangle* (x y :width w :height h)
                 (region-intersection region window-region)
               (let* ((x (max (floor x) 0))
                      (y (max (floor y) 0))
                      (w (ceiling w))
                      (h (ceiling h)))
                 (xlib::put-image window gcontext clx-image
                                  :src-x x :src-y y :x x :y y
                                  :width w :height h)))))
      (declare (dynamic-extent #'put-it))
      (map-over-region-set-regions #'put-it dirty-region))))

(defun image-mirror-to-x (mirror)
  (declare (optimize speed))
  (unless (region-equal (image-dirty-region mirror) +nowhere+)
    (with-image-locked (mirror)
      (let* ((dirty (image-dirty-region mirror))
             (image (image-mirror-image mirror)))
        (unless (region-equal dirty +nowhere+)
          (setf (image-dirty-region mirror) +nowhere+)
          (image-mirror-put mirror image dirty))))))

(defun %mirror-force-output (mirror)
  (image-mirror-to-x mirror))
